import os

input_filename = "function_complexities.txt"
output_filename = "sorted_untested_functions_by_complexity.txt"

functions_with_complexity = []

try:
    with open(input_filename, "r") as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) == 2:
                func_name = parts[0]
                try:
                    complexity = int(parts[1])
                    functions_with_complexity.append((func_name, complexity))
                except ValueError:
                    print(f"Warning: Could not parse complexity for '{func_name}' from line: {line.strip()}. Skipping.")
            elif line.strip(): # Report only if line is not empty
                print(f"Warning: Malformed line in {input_filename}: {line.strip()}. Skipping.")
except FileNotFoundError:
    print(f"Error: {input_filename} not found. Make sure it was generated by the previous step.")
    # To ensure the tool doesn't fail if this script is part of a larger chain,
    # create an empty output file and exit gracefully.
    with open(output_filename, "w") as out_f:
        pass # Create empty file
    exit(0) # Exit normally so as not to halt a pipeline if this is non-critical

if not functions_with_complexity:
    print(f"No function complexity data found or parsed from {input_filename}.")
    with open(output_filename, "w") as out_f:
        pass # Create empty file
    exit(0)

# Sort by complexity (primary key, ascending) and then by function name (secondary key, ascending)
functions_with_complexity.sort(key=lambda x: (x[1], x[0]))

try:
    with open(output_filename, "w") as out_f:
        for func_name, complexity in functions_with_complexity:
            out_f.write(f"{func_name} {complexity}\n") # Ensure newline
except IOError as e:
    print(f"Error writing sorted data to {output_filename}: {e}")
    # Consider if script should exit(1) here based on severity
    exit(1)

print(f"Successfully sorted functions by complexity into {output_filename}.")
